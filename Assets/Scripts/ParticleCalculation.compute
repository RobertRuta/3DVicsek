// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateParticles
#pragma kernel UpdateGrid

struct Particle
{
    float3 position;
    float3 velocity;
    float3 color;
};


RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<uint2> cellparticleindices;
RWStructuredBuffer<uint> particleIDs;
RWStructuredBuffer<uint> cellIDs;



float deltaTime;
float speed;
float radius;
float cellDim;
float3 box;
uint3 gridDims;


// Binds particles to box. If particle leaves box it is teleported to other side.
float3 BoundToBox(float3 pos)
{
    [branch] if(pos.x > box.x)
    {
       pos.x -= box.x;
    }
    [branch] if(pos.x < 0.0)
    {
        pos.x += box.x;
    }
    [branch] if(pos.y > box.y)
    {
        pos.y -= box.y;
    }
    [branch] if(pos.y < 0.0)
    {
        pos.y += box.y;
    }
    [branch] if(pos.z > box.z)
    {
        pos.z -= box.z;
    }
    [branch] if(pos.z < 0.0)
    {
        pos.z += box.z;
    }

    return pos;
}

uint3 CalcGridCoords(float3 pos)
{
    // cell {0, 0, 0} is found at coordinate origin and has index 0
    uint cellX = (uint) (pos.x / cellDim);
    uint cellY = (uint) (pos.y / cellDim);
    uint cellZ = (uint) (pos.z / cellDim);
    uint3 cellXYZ = {cellX, cellY, cellZ};

    return cellXYZ;
}

// Computes cell id given particle position
uint CalcCellID(float3 pos)
{
    uint3 cellPos = CalcGridCoords(pos);
    uint cellID = cellPos.x + cellPos.y*gridDims.x + cellPos.z*gridDims.x*gridDims.y;

    return cellID;
}

// Use this function to compute the velocities of neighbours
float3 ComputeNeighbourVelocities(uint pID)
{
    uint cell = CalcCellID(pID);
    float3 temp = {0, 0, 0};
    return temp;
}


[numthreads(128,1,1)]
void UpdateParticles (uint3 id : SV_DispatchThreadID)
{
    uint pID = id.x;


    //Updated Particle Velocities
        //Set particle velocities to normalised sum of neighbour velocities
    //particles[id.x].velocity = ComputeNeighbourVelocities(id.x);
    
    //Updated Particle Positions
    particles[id.x].position += particles[id.x].velocity * deltaTime;

    //Keep particles in a box - teleport from one side to the other when crossing boundary
    particles[id.x].position = BoundToBox(particles[id.x].position);

    // Set particle colours
    particles[id.x].color = float3(0,0.5f,1);
}


[numthreads(128,1,1)]
void UpdateGrid (uint3 id : SV_DispatchThreadID)
{
    uint pID = id.x;    
    float3 pos = particles[pID].position;
    uint cell = CalcCellID(pos);

    particleIDs[pID] = pID;
    cellIDs[pID] = cell;
}


[numthreads(128,1,1)]
void SortIndices (uint3 id : SV_DispatchThreadID)
{
    uint ID = id.x;
    // Figure out a way to sort cellparticleindicesbuffer... and change that ugly ass name
    // This may be obsolete comment, we'll see if sorter works

}